"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __importDefault(require("../index"));
const react_hooks_1 = require("@testing-library/react-hooks");
const initialState = { count: 0 };
function reducer(state, action) {
    switch (action.type) {
        case 'increment':
            return { count: state.count + 1 };
        case 'decrement':
            return { count: state.count - 1 };
        case 'double-increment':
            return { count: state.count + 2 };
        case 'double-decrement':
            return { count: state.count - 2 };
        case 'reset':
            return { count: 0 };
        default:
            return state;
    }
}
describe('useOptimisticState', () => {
    test('returns correct initial state', () => {
        const { result } = react_hooks_1.renderHook(() => index_1.default(reducer, initialState));
        const [state, dispatch] = result.current;
        expect(state).toEqual(initialState);
        expect(typeof dispatch).toBe('function');
    });
    test('returns correct state after dispatching action', () => {
        const { result } = react_hooks_1.renderHook(() => index_1.default(reducer, initialState));
        react_hooks_1.act(() => {
            result.current[1]({ type: 'increment' });
        });
        expect(result.current[0].count).toBe(1);
    });
    test('returns correct state after dispatching optimistic action', () => {
        const { result } = react_hooks_1.renderHook(() => index_1.default(reducer, initialState));
        react_hooks_1.act(() => {
            result.current[1]({
                type: 'increment',
                optimistic: {
                    callback: async () => { }
                }
            });
        });
        expect(result.current[0].count).toBe(1);
    });
    test('correctly executes optimistic callback', () => {
        const { result } = react_hooks_1.renderHook(() => index_1.default(reducer, initialState));
        const [, dispatch] = result.current;
        react_hooks_1.act(() => {
            result.current[1]({
                type: 'increment',
                optimistic: {
                    callback: async () => {
                        dispatch({ type: 'increment' });
                        dispatch({ type: 'increment' });
                    }
                }
            });
        });
        expect(result.current[0].count).toBe(3);
    });
    test('returns correct state after fallback', () => {
        const { result } = react_hooks_1.renderHook(() => index_1.default(reducer, initialState));
        const [, dispatch] = result.current;
        react_hooks_1.act(() => {
            dispatch({
                type: 'increment',
                optimistic: {
                    callback: async () => {
                        throw 'Error';
                    },
                    fallback: (state) => {
                        expect(state.count).toBe(0);
                    }
                }
            });
        });
        expect(result.current[0].count).toBe(1);
    });
});
